# class对象？

在 Java 中，`Class` 类型的对象是由 `java.lang.Class` 类的实例所表示的。每当我们编写并编译一个新类时，Java 编译器会为该类生成一个对应的 `Class` 对象，并将其保存在同名的 `.class` 文件中。当程序运行时，Java 虚拟机（JVM）通过类加载器将这些 `Class` 对象加载到内存中。需要注意的是，无论我们创建多少个该类的实例对象，在 JVM 中都只有一个与之对应的 `Class` 对象。 

`Class` 对象主要包含以下信息：

1. **类的名称**：包括完整的包名和类名。
2. **类的修饰符**：如 `public`、`abstract`、`final` 等。
3. **包信息**：该类所属的包。
4. **类的直接超类（父类）**：即该类继承的父类。
5. **实现的接口**：该类实现的所有接口。
6. **字段（成员变量）信息**：包括字段的名称、类型、修饰符等。
7. **方法信息**：包括方法的名称、返回类型、参数类型、修饰符等。
8. **构造方法信息**：包括构造方法的参数类型、修饰符等。
9. **注解信息**：该类上所使用的注解。



# JVM如何保证Class对象的唯一性？

在 Java 中，每个类在运行时都会由 Java 虚拟机（JVM）创建一个唯一的 `Class` 对象来表示该类的元数据。这意味着对于同一个类，无论创建多少实例，都共享同一个 `Class` 对象。JVM 通过类加载器（ClassLoader）机制来确保这一点。

当需要加载一个类时，JVM 首先检查该类是否已经被加载：

1. **类加载检查**：JVM 会查询当前的类加载器是否已加载过该类。如果已加载，则直接返回该类的 `Class` 对象。
2. **类加载过程**：如果类尚未加载，类加载器会读取对应的字节码文件（`.class` 文件），然后将其转换为 `Class` 对象并存储在方法区（在较新的 JVM 实现中，方法区可能被称为元空间）。
3. **缓存机制**：类加载器通常会维护一个缓存，记录已经加载的类。这样可以确保对于同一个类，只加载一次并生成一个 `Class` 对象。



# 获取class对象的三种方式

- Class.forName("全类名")
- 类名.class
- 对象.getClass()